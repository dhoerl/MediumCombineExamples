<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Simple Combine Publisher, Subscriber, and Operator with back pressure</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Simple Combine Publisher, Subscriber, and Operator with back pressure</h1>
</header>
<section data-field="subtitle" class="p-summary">
Dirt simple Combine examples that all demonstrate back pressure.
</section>
<section data-field="body" class="e-content">
<section name="3cf3" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1bc5" id="1bc5" class="graf graf--h3 graf--leading graf--title">Simple Combine Publisher, Subscriber, and Operator with back pressure</h3><p name="b8c2" id="b8c2" class="graf graf--p graf-after--h3">Dirt simple Combine examples that all demonstrate back pressure.</p><figure name="d717" id="d717" class="graf graf--figure graf-after--p graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 556px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 79.5%;"></div><img class="graf-image" data-image-id="1*kp-s2hWRXC6oAGy1MRUjfg.jpeg" data-width="4060" data-height="3226" data-is-featured="true" alt="Industrial Pipes" src="https://cdn-images-1.medium.com/max/800/1*kp-s2hWRXC6oAGy1MRUjfg.jpeg"></div><figcaption class="imageCaption">Photo by <a href="https://unsplash.com/@realaxer" data-href="https://unsplash.com/@realaxer" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Tian Kuan</a> on <a href="https://unsplash.com" data-href="https://unsplash.com" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Unsplash</a></figcaption></figure></div></div></section><section name="7536" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3f8d" id="3f8d" class="graf graf--h3 graf--leading">Abstract</h3><p name="ee8d" id="ee8d" class="graf graf--p graf-after--h3">I’ve read many tutorials and in-depth treatments of <em class="markup--em markup--p-em">Combine</em>, and it’s taken me a long time to “get”<em class="markup--em markup--p-em"> </em>it. What Apple gives us are protocol definitions for the various components, and a framework with many prebuilt components—unfortunately no example code yet.</p><p name="e5ba" id="e5ba" class="graf graf--p graf-after--p">So I embarked on a project to build a simple bare-boned <em class="markup--em markup--p-em">Publisher</em>, <em class="markup--em markup--p-em">Subscriber</em>, <em class="markup--em markup--p-em">Publisher-Subscriber</em> (my term, which I call a <em class="markup--em markup--p-em">Complex Publisher</em> here), and <em class="markup--em markup--p-em">Operator</em>. In addition, I really wanted to explore how <em class="markup--em markup--p-em">backpressure</em> worked, to support it in my own code, and to look for problematic edge cases, which I did find.</p><p name="3a3b" id="3a3b" class="graf graf--p graf-after--p">I’m going to first present a simple UNIX shell pipeline, then reconstitute it using <em class="markup--em markup--p-em">Combine</em>. You’ll see about how <em class="markup--em markup--p-em">Combine’s</em> <em class="markup--em markup--p-em">backpressure</em> works, and how to adapt a <em class="markup--em markup--p-em">Complex Publisher</em> to construct an <em class="markup--em markup--p-em">Operator</em>.</p><h3 name="7200" id="7200" class="graf graf--h3 graf-after--p">Introduction</h3><p name="2e15" id="2e15" class="graf graf--p graf-after--h3">I started with C and UNIX decades ago, and in 2005 struggled to “get” Object Oriented Programming in Objective C. Then last summer, Apple introduced <em class="markup--em markup--p-em">SwiftUI</em> and <em class="markup--em markup--p-em">Combine</em>, which leverage F<em class="markup--em markup--p-em">unctional Reactive Programming</em> concepts. Yikes! Its Deja Vu all over again!</p><p name="112d" id="112d" class="graf graf--p graf-after--p">Browsing Medium and elsewhere, I found many complex examples that do complex things, but it was overwhelming! What I really wanted was something dirt simple, so I could wrap my hands around the various concepts. Not finding anything, I decided to do create some myself—what follows here.</p><p name="2303" id="2303" class="graf graf--p graf-after--p">There is another <em class="markup--em markup--p-em">Combine</em> component—<em class="markup--em markup--p-em">Subject</em>s—which you can programmatically control. They get lots of coverage so I don’t mention them. What does follow is just plain ole Swift code.</p><p name="9f1a" id="9f1a" class="graf graf--p graf-after--p">In many ways, <em class="markup--em markup--p-em">Combine</em> networks looks like <a href="https://toroid.org/unix-pipe-implementation" data-href="https://toroid.org/unix-pipe-implementation" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">UNIX pipes</a>: the first component (<strong class="markup--strong markup--p-strong">Publisher</strong>) generates data and sends it downstream, intermediate components (<strong class="markup--strong markup--p-strong">Operators</strong>) modify the incoming data before fowarding it on, then a final component (<strong class="markup--strong markup--p-strong">Subscriber</strong>) receives the final result. <em class="markup--em markup--p-em">Combine</em> supports more complicated graphs, but this is the basic one.</p><p name="0aad" id="0aad" class="graf graf--p graf-after--p">In UNIX, here’s a really simple shell pipeline:</p><pre name="9a9a" id="9a9a" class="graf graf--pre graf-after--p">echo &quot;Hello World&quot; | tr &quot;[:lower:]&quot; &quot;[:upper:]&quot; | awk -v FS=&quot;&quot; &#39;{<br>    for (i=1;i&lt;=NF;i++) {<br>        if(i == 1) {<br>            printf &quot;Chars: &quot; $i<br>        }  else {<br>            printf &quot; &quot;$i<br>        }<br>    }<br>}&#39;</pre><p name="3e83" id="3e83" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Echo</em> is the <em class="markup--em markup--p-em">Publisher </em>(of a string), <em class="markup--em markup--p-em">tr</em> is the <em class="markup--em markup--p-em">Operator</em> (translate lower case to upper case), and <em class="markup--em markup--p-em">awk</em> is the <em class="markup--em markup--p-em">Subscriber</em> (prints each character separated by a space)<em class="markup--em markup--p-em">.</em></p><p name="0dd8" id="0dd8" class="graf graf--p graf-after--p">Input: <em class="markup--em markup--p-em">Hello World</em>, Output: <code class="markup--code markup--p-code">Chars: H E L L O W O R L D</code></p><p name="c048" id="c048" class="graf graf--p graf-after--p">We’re going to replicate it using <em class="markup--em markup--p-em">Combine</em> elements. Both support <em class="markup--em markup--p-em">backpressure</em>, meaning that <em class="markup--em markup--p-em">Operators</em> and <em class="markup--em markup--p-em">Subscribers</em> can throttle upstream <em class="markup--em markup--p-em">Publishers</em>: UNIX <em class="markup--em markup--p-em">pipes</em> themselves provide this (not the individual programs). <em class="markup--em markup--p-em">Combine</em> does it cooperatively by restricting <em class="markup--em markup--p-em">Publishers</em> to only output data up to a <em class="markup--em markup--p-em">Subscriber</em> specified limit.</p><p name="65c1" id="65c1" class="graf graf--p graf-after--p">Something that took me a really long time to grasp: while a simple <em class="markup--em markup--p-em">Publisher</em> only produces data to send downstream, a <em class="markup--em markup--p-em">Complex Publisher</em> (my term) also provides a <em class="markup--em markup--p-em">Subscriber</em> interface to attach to an upstream <em class="markup--em markup--p-em">Publisher</em>.</p><p name="e9d2" id="e9d2" class="graf graf--p graf-after--p">Then there’s <em class="markup--em markup--p-em">Operator</em>: a often trivial function within a <em class="markup--em markup--p-em">Publisher</em> extension that can wrap a C<em class="markup--em markup--p-em">omplex Publisher</em> (or <em class="markup--em markup--p-em">Subscriber)</em>, thus allowing it to be used in a function chain.</p><p name="ee6b" id="ee6b" class="graf graf--p graf-after--p">I’ve avoided discussing errors and cancellation — you will find many other articles cover these topics in depth—but the full code (on <a href="https://github.com/dhoerl/MediumCombineExamples" data-href="https://github.com/dhoerl/MediumCombineExamples" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Github</a>) supports cancellation, and generates an error if the <em class="markup--em markup--p-em">String</em> argument is empty.</p><h3 name="e13e" id="e13e" class="graf graf--h3 graf-after--p">Simple Publisher</h3><p name="ee8e" id="ee8e" class="graf graf--p graf-after--h3">Most examples I’ve seen use a <em class="markup--em markup--p-em">struct</em> to conform to the <em class="markup--em markup--p-em">Publisher</em> protocol, but a <em class="markup--em markup--p-em">Class</em> should work too. Our <em class="markup--em markup--p-em">Publisher</em> example will mimic <em class="markup--em markup--p-em">echo “Hello World”</em>, and this is how it begins:</p><pre name="d6f6" id="d6f6" class="graf graf--pre graf-after--p">struct StringPublisher: Publisher {<br> typealias Output = [Character]<br> typealias Failure = Error</pre><pre name="c281" id="c281" class="graf graf--pre graf-after--pre"> private let data: [Character]</pre><pre name="6516" id="6516" class="graf graf--pre graf-after--pre"> init(string: String) {<br>  self.data = string.map({$0})<br> }</pre><pre name="da3e" id="da3e" class="graf graf--pre graf-after--pre"> func receive&lt;S&gt;(subscriber: S) where<br>  S: Subscriber,<br>  S.Failure == Self.Failure,<br>  S.Input == Self.Output<br> {<br>  let subscription = StringPublisherSubscription(subscriber: subscriber, data: data)<br>  subscriber.receive(subscription: subscription)<br> }<br>...</pre><p name="f836" id="f836" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">Publishers</em> are <em class="markup--em markup--p-em">generic</em>, so they have <em class="markup--em markup--p-em">associated types</em> of <em class="markup--em markup--p-em">Output</em> and <em class="markup--em markup--p-em">Failure </em>as you see above. A <em class="markup--em markup--p-em">StringPublisher</em> is created by providing a <em class="markup--em markup--p-em">String</em> (i.e., <code class="markup--code markup--p-code">StringPublisher(string: “Hello World”)</code>). Once created, nothing more happens until some <em class="markup--em markup--p-em">Subscriber</em> subscribes to it via the <code class="markup--code markup--p-code">receive</code> function. Note that the <em class="markup--em markup--p-em">Subscriber</em> must have inputs that match the <em class="markup--em markup--p-em">Publishers</em> outputs.</p><p name="5cb8" id="5cb8" class="graf graf--p graf-after--p">All custom <em class="markup--em markup--p-em">Publisher</em> examples I’ve seen use a class object to create a custom <em class="markup--em markup--p-em">Subscription</em>, as I’ll do:</p><pre name="0629" id="0629" class="graf graf--pre graf-after--p">final class StringPublisherSubscription&lt;S&gt;: Subscription where<br>  S: Subscriber,<br>  S.Input == [Character],<br>  S.Failure == Error<br> {<br>   private var subscriber: S?<br>   private var data: [Character]<br>   private var runningDemand: Subscribers.Demand = .max(0)<br>   private var isFinished = false</pre><pre name="4c52" id="4c52" class="graf graf--pre graf-after--pre">   init(subscriber: S, data: [Character]) {<br>      self.subscriber = subscriber<br>      self.data = data<br>   }<br>...</pre><p name="e2ed" id="e2ed" class="graf graf--p graf-after--pre">It needs to know the <code class="markup--code markup--p-code">subscriber</code>, and the data, as it will be sending that data as requested later. It can be initialized with as many parameters as desired; for this simple <em class="markup--em markup--p-em">Publisher</em> its just the <em class="markup--em markup--p-em">String</em> morphed into a <em class="markup--em markup--p-em">Character</em> array. This object can also be an <em class="markup--em markup--p-em">NSObject</em> subclass, which makes it possible for it to be a delegate to Objective C based objects.</p><p name="c166" id="c166" class="graf graf--p graf-after--p">You can write your <em class="markup--em markup--p-em">Subscription</em> class within the <em class="markup--em markup--p-em">Publisher</em> itself, to <em class="markup--em markup--p-em">namespace</em> it—a popular technique.</p><h4 name="9cb4" id="9cb4" class="graf graf--h4 graf-after--p">Demand</h4><p name="970d" id="970d" class="graf graf--p graf-after--h4">The <em class="markup--em markup--p-em">Subscription</em> has a <code class="markup--code markup--p-code">receive</code> function, which the downstream <em class="markup--em markup--p-em">Subscriber</em> uses to request data. However, that function only gets a <em class="markup--em markup--p-em">Demand</em> (i.e. <code class="markup--code markup--p-code">request</code>) for some amount of data. <em class="markup--em markup--p-em">Demand</em> is interesting, as it’s either <code class="markup--code markup--p-code">infinite</code> or an <code class="markup--code markup--p-code">Int</code>—the <code class="markup--code markup--p-code">Int</code> could mean one byte, one object, or a whole file.</p><p name="666e" id="666e" class="graf graf--p graf-after--p">It appears that each <code class="markup--code markup--p-code">demand</code> should be additive to whatever was requested before minus any data sent, although Apple’s docs don’t really make that clear. So, each <em class="markup--em markup--p-em">receive’s</em> <code class="markup--code markup--p-code">demand</code> is added to a cumulative <code class="markup--code markup--p-code">demand</code>, and each time the <em class="markup--em markup--p-em">Subscription</em> sends data, that cumulative <code class="markup--code markup--p-code">demand</code> is reduced by the same amount sent.</p><p name="c920" id="c920" class="graf graf--p graf-after--p">Data is sent to the <em class="markup--em markup--p-em">Subscriber</em> via its <code class="markup--code markup--p-code">receive</code> function. That function returns a <code class="markup--code markup--p-code">demand</code>, which Apple says is <em class="markup--em markup--p-em">how many more elements are expected</em>. Theoretically IMHO it should be the same as the computed cumulative <code class="markup--code markup--p-code">demand</code> at that moment.</p><p name="c51d" id="c51d" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Demand</code> has a <code class="markup--code markup--p-code">max</code> property, which is <code class="markup--code markup--p-code">nil</code> when the <code class="markup--code markup--p-code">demand</code> is <code class="markup--code markup--p-code">infinite</code>. Much of the code I’ve seen assumes this and does not throttle output, however <em class="markup--em markup--p-em">Combine</em> documentation emphasizes that <em class="markup--em markup--p-em">Publishers</em> must never send <em class="markup--em markup--p-em">Subscribers</em> more data than requested. All <em class="markup--em markup--p-em">Subscribers</em> here request just one element so we can explore the implications on the code.</p><h4 name="bfd4" id="bfd4" class="graf graf--h4 graf-after--p">Sending Data via <em class="markup--em markup--h4-em">Receive</em></h4><p name="cd4d" id="cd4d" class="graf graf--p graf-after--h4">When a <em class="markup--em markup--p-em">Subscription</em> has a non-zero <code class="markup--code markup--p-code">demand</code> and it has or receives data, it should asynchronously send it, up to the outstanding <code class="markup--code markup--p-code">demand</code>. Thus real-world <em class="markup--em markup--p-em">Subscriptions</em> must have some sort of elastic buffer (moot if the <code class="markup--code markup--p-code">demand</code> is infinite, but any given <em class="markup--em markup--p-em">Publisher</em> never knows what will be requested), unless you believe your data can get dropped on the floor (discussed further below).</p><p name="9b61" id="9b61" class="graf graf--p graf-after--p">This architecture raises interesting questions on exactly when and how a <em class="markup--em markup--p-em">Subscription</em> should send the data. Imagine that it has a massive amount, gets a <code class="markup--code markup--p-code">request</code> for 100 elements and sends 100. The <em class="markup--em markup--p-em">Subscriber</em>, in its <code class="markup--code markup--p-code">receive</code> function, requests a 100 more, etc. Code needs to allow for this and not infinitely recurse on the stack, again IMHO.</p><h4 name="262b" id="262b" class="graf graf--h4 graf-after--p">Simple Receive</h4><p name="9e4f" id="9e4f" class="graf graf--p graf-after--h4">In the example <em class="markup--em markup--p-em">Publisher</em>, the <em class="markup--em markup--p-em">Subscriber</em> is messaged directly:</p><pre name="d3f2" id="d3f2" class="graf graf--pre graf-after--p">func request(_ demand: Subscribers.Demand) {<br> guard !isFinished else { return }<br> guard let subscriber = subscriber else { return }<br> guard data.count &gt; 0 else {return sendError(.inputStringWasEmpty)}</pre><pre name="605c" id="605c" class="graf graf--pre graf-after--pre"> runningDemand += demand</pre><p name="cb85" id="cb85" class="graf graf--p graf-after--pre">After insuring we can continue, the <code class="markup--code markup--p-code">runningDemand</code> is increased by the <code class="markup--code markup--p-code">demand</code> parameter (obviously if the original is <code class="markup--code markup--p-code">infinite</code>, this has no effect).</p><pre name="75cf" id="75cf" class="graf graf--pre graf-after--p">if isProcessingRequest == true {<br> return<br>} else {<br> isProcessingRequest = true<br>}</pre><p name="7c11" id="7c11" class="graf graf--p graf-after--pre">The above test prevents recursion if the <em class="markup--em markup--p-em">Subscriber</em> messages it with another <em class="markup--em markup--p-em">request</em> within the <em class="markup--em markup--p-em">receive</em> message.</p><pre name="8fe5" id="8fe5" class="graf graf--pre graf-after--p">while runningDemand &gt; 0 &amp;&amp; !data.isEmpty {<br> let count = computeSendCount()<br> let tempData: [Character] = Array( data.prefix(upTo: count) )<br> let stillDesired = subscriber.receive(tempData)</pre><pre name="78d4" id="78d4" class="graf graf--pre graf-after--pre"> // Only update counts and data AFTER sending receive<br> data.removeSubrange(0..&lt;count)<br> runningDemand -= count<br> if let runningDesired = runningDemand.max, let stillDesired = stillDesired.max {<br>  assert(runningDesired == stillDesired)<br> }<br>}</pre><p name="2b2d" id="2b2d" class="graf graf--p graf-after--pre">The while loop exists because the <em class="markup--em markup--p-em">Subscriber</em> could send <code class="markup--code markup--p-code">request</code> inside the <code class="markup--code markup--p-code">receive</code> : since it might have done this (and increased <em class="markup--em markup--p-em">runningDemand),</em> we just loop until supply and demand have equalized.</p><p name="d13c" id="d13c" class="graf graf--p graf-after--p">Once the <em class="markup--em markup--p-em">Subscription’s</em> data has been exhausted, the <code class="markup--code markup--p-code">subscriber</code> is told that the <em class="markup--em markup--p-em">Subscription</em> has finished. Complete code:</p><figure name="3e05" id="3e05" class="graf graf--figure graf--iframe graf-after--p"></figure><h4 name="a3e0" id="a3e0" class="graf graf--h4 graf-after--figure">Test</h4><p name="333f" id="333f" class="graf graf--p graf-after--h4">We can test our <em class="markup--em markup--p-em">Publisher</em> using a built in <em class="markup--em markup--p-em">sink Subscriber</em>, which requests infinite elements:</p><pre name="6b32" id="6b32" class="graf graf--pre graf-after--p">var count = 0<br>let _ = StringPublisher(string: &quot;Hello World&quot;).sink(<br> receiveCompletion: { completion in<br>  switch completion {<br>  case .failure(let err):<br>   print(&quot;\nERROR: &quot;, err)<br>  case .finished:<br>   print(&quot;\nFINISHED&quot;)<br>  }<br> }) { (chars: [Character]) in<br>  chars.forEach({ print(count == 0 ? &quot;Char:&quot; : &quot; &quot;, $0, terminator: &quot;&quot;); count += 1 })<br> }</pre><p name="992c" id="992c" class="graf graf--p graf-after--pre">Output: <code class="markup--code markup--p-code">Char: H e l l o W o r l d FINISHED</code></p><h3 name="0639" id="0639" class="graf graf--h3 graf-after--p">Subscriber</h3><p name="c7ca" id="c7ca" class="graf graf--p graf-after--h3">This simple <em class="markup--em markup--p-em">Subscriber</em> will request a single character, and within each <em class="markup--em markup--p-em">receive</em> <em class="markup--em markup--p-em">request</em> one more.</p><figure name="906c" id="906c" class="graf graf--figure graf--iframe graf-after--p"></figure><h4 name="e28c" id="e28c" class="graf graf--h4 graf-after--figure">Test</h4><p name="0b6a" id="0b6a" class="graf graf--p graf-after--h4">We can connect the <em class="markup--em markup--p-em">Publisher</em> and <em class="markup--em markup--p-em">Subscriber</em> together now:</p><pre name="cc51" id="cc51" class="graf graf--pre graf-after--p">let publisher = StringPublisher(string: &quot;Hello World&quot;)<br>let subcriber = StringSubscriber()<br>publisher.subscribe(subcriber)</pre><p name="93a4" id="93a4" class="graf graf--p graf-after--pre">Output: <code class="markup--code markup--p-code">Char: H e l l o W o r l d Subscriber completion finished</code></p><h3 name="465a" id="465a" class="graf graf--h3 graf-after--p">Complex Publisher (i.e., Subscriber-Publisher)</h3><p name="f3f6" id="f3f6" class="graf graf--p graf-after--h3">We’re now going to create a component that meets both <em class="markup--em markup--p-em">Publisher</em> and <em class="markup--em markup--p-em">Subscriber</em> protocols—it’s a bit more tricky. Credit for this code goes to <a href="https://www.cocoawithlove.com/about/" data-href="https://www.cocoawithlove.com/about/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Matt Gallagher</a>, since I followed the steps listed in his excellent <a href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-1.html" data-href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-1.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Combine</a> article (see <em class="markup--em markup--p-em">Custom implementations</em>).</p><p name="026c" id="026c" class="graf graf--p graf-after--p">The <em class="markup--em markup--p-em">Subscription</em> produced by this <em class="markup--em markup--p-em">Publisher</em> has to also adopt the <em class="markup--em markup--p-em">Subscriber </em>protocol:</p><pre name="b4e3" id="b4e3" class="graf graf--pre graf-after--p">struct UpperCasePublisher: Publisher {<br> typealias Output = [Character]<br> typealias Failure = Error</pre><pre name="feec" id="feec" class="graf graf--pre graf-after--pre"> let upstreamPublisher: AnyPublisher&lt;Output, Error&gt;</pre><pre name="0e8e" id="0e8e" class="graf graf--pre graf-after--pre"> init(upstream: AnyPublisher&lt;Output, Error&gt;) {<br>  self.upstreamPublisher = upstream<br> }</pre><pre name="dc03" id="dc03" class="graf graf--pre graf-after--pre"> func receive&lt;S&gt;(subscriber: S) where<br>  S: Subscriber,<br>  S.Failure == Self.Failure,<br>  S.Input == Self.Output<br> {<br>  let subscription = UpperCaseSubscription(subscriber: subscriber, upstream: upstreamPublisher)<br>  upstreamPublisher.subscribe(subscription)<br> }</pre><pre name="650f" id="650f" class="graf graf--pre graf-after--pre"> final class UpperCaseSubscription&lt;S, P: Publisher&gt;: Subscription, Subscriber where<br>  S: Subscriber,<br>  S.Input == Output,<br>  S.Failure == Error<br> {<br> ...</pre><p name="b060" id="b060" class="graf graf--p graf-after--pre">You can see that we need to supply <em class="markup--em markup--p-em">UpperCasePublisher</em> with the upstream <em class="markup--em markup--p-em">Publisher</em>, and it maintains that reference until it receives a subscription <em class="markup--em markup--p-em">request</em> from downstream: that <em class="markup--em markup--p-em">receive</em> message prompts it to create a <em class="markup--em markup--p-em">subscription</em> object, and pass that to the upstream <em class="markup--em markup--p-em">Publisher</em>. At this point the <em class="markup--em markup--p-em">UpperCasePublisher</em> struct can be discarded: <em class="markup--em markup--p-em">Publishers</em> exist for short periods until they produce a <em class="markup--em markup--p-em">Subscription</em>.</p><p name="e62d" id="e62d" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">UpperCaseSubscription</em> essentially merges both the <em class="markup--em markup--p-em">Subscription</em> and <em class="markup--em markup--p-em">Subscriber</em> code already presented. Since it needs to accommodate cases where demand outruns supply and vice versa, it’s a bit more complex:</p><pre name="b18d" id="b18d" class="graf graf--pre graf-after--p">final class UpperCaseSubscription&lt;S, P: Publisher&gt;: Subscription, Subscriber where<br> S: Subscriber,<br> S.Input == Output,<br> S.Failure == Error<br>{<br> typealias Input = P.Output   // for Subscriber<br> typealias Failure = P.Failure // for Subscriber</pre><pre name="460d" id="460d" class="graf graf--pre graf-after--pre"> private var data: [Character] = []<br> private var isProcessingRequest = false</pre><pre name="c941" id="c941" class="graf graf--pre graf-after--pre"> // Upstream Related<br> private var upstreamSubscription: Subscription?<br> private var isUpstreamFinished = false</pre><pre name="396b" id="396b" class="graf graf--pre graf-after--pre"> // Downstream Related<br> private var downstreamSubscriber: S?<br> private var isDownstreamCancelled = false<br> private var runningDemand: Subscribers.Demand = .max(0)</pre><pre name="918f" id="918f" class="graf graf--pre graf-after--pre"> init(subscriber: S, upstream: P) {<br>  // P lets us define the associated types<br>  self.downstreamSubscriber = subscriber<br> }<br> ...</pre><p name="7907" id="7907" class="graf graf--p graf-after--pre">You can see it has both <em class="markup--em markup--p-em">Subscriber</em> and <em class="markup--em markup--p-em">Publisher</em> references (ivars).</p><pre name="9ab3" id="9ab3" class="graf graf--pre graf-after--p">// MARK: - Downstream Subscriber</pre><pre name="3836" id="3836" class="graf graf--pre graf-after--pre">func request(_ demand: Subscribers.Demand) {<br>  guard !isDownstreamCancelled else { return }<br>  guard let downstreamSubscriber = downstreamSubscriber else {<br>   return<br>  }</pre><pre name="0e35" id="0e35" class="graf graf--pre graf-after--pre">  runningDemand += demand</pre><pre name="5fc9" id="5fc9" class="graf graf--pre graf-after--pre">  if isProcessingRequest == true {<br>   return<br>  } else {<br>   isProcessingRequest = true<br>  }</pre><pre name="f62b" id="f62b" class="graf graf--pre graf-after--pre">  while runningDemand &gt; 0 &amp;&amp; !data.isEmpty {<br>   let count = computeSendCount()<br>   let tempData: [Character] = Array( data.prefix(upTo: count) )<br>   data.removeSubrange(0..&lt;count)</pre><pre name="862a" id="862a" class="graf graf--pre graf-after--pre">   let stillWant = downstreamSubscriber.receive(tempData)<br>   if let desired = runningDemand.max, desired == 0 {<br>    runningDemand += stillWant<br>   }<br>  }</pre><pre name="47a1" id="47a1" class="graf graf--pre graf-after--pre">  if isUpstreamFinished &amp;&amp; data.isEmpty {<br>   downstreamSubscriber.receive(completion: .finished)<br>  }</pre><pre name="4e2b" id="4e2b" class="graf graf--pre graf-after--pre">  isProcessingRequest = false<br> }<br> ...</pre><p name="8eec" id="8eec" class="graf graf--p graf-after--pre">The big difference above is that <code class="markup--code markup--p-code">data</code> may be emptied while the upstream <em class="markup--em markup--p-em">Publisher</em> is still running: thus, we need to wait until it signals us that it’s finished.</p><pre name="bae6" id="bae6" class="graf graf--pre graf-after--p">// MARK: - Upstream Subscription</pre><pre name="659a" id="659a" class="graf graf--pre graf-after--pre"> func receive(subscription: Subscription) {<br>  downstreamSubscriber?.receive(subscription: self)</pre><pre name="eab1" id="eab1" class="graf graf--pre graf-after--pre">  upstreamSubscription = subscription<br>  upstreamSubscription?.request(.max(1))<br> }</pre><pre name="b535" id="b535" class="graf graf--pre graf-after--pre"> func receive(_ input: Input) -&gt; Subscribers.Demand {<br>  guard let input = input as? [Character] else { fatalError() }</pre><pre name="bc2b" id="bc2b" class="graf graf--pre graf-after--pre">  input.forEach({<br>   let s = $0.uppercased()<br>   s.forEach({ data.append($0) })<br>  })</pre><pre name="9a60" id="9a60" class="graf graf--pre graf-after--pre">  request(.max(0))<br>  return .max(1)<br> }</pre><pre name="54f4" id="54f4" class="graf graf--pre graf-after--pre"> func receive(completion: Subscribers.Completion&lt;P.Failure&gt;) {<br>  isUpstreamFinished = true</pre><pre name="961d" id="961d" class="graf graf--pre graf-after--pre">  switch completion {<br>  case .finished:<br>   request(.max(0))<br>  case .failure(let error):<br>   downstreamSubscriber?.receive(completion: .failure(error))<br>  }<br> }<br> ...</pre><p name="71ad" id="71ad" class="graf graf--p graf-after--pre">Above, the big addition is that in receive, the data is now transformed from lower to upper case. In addition, after processing and relaying the data received, it returns a <em class="markup--em markup--p-em">demand</em> of 1.</p><figure name="ce9a" id="ce9a" class="graf graf--figure graf--iframe graf-after--p"></figure><h4 name="4de9" id="4de9" class="graf graf--h4 graf-after--figure">Test</h4><p name="a52b" id="a52b" class="graf graf--p graf-after--h4">We now have all we need to set up a chain like the UNIX command line:</p><pre name="8b60" id="8b60" class="graf graf--pre graf-after--p">let p1 = StringPublisher(string: &quot;Hello World&quot;)<br>let p2 = UpperCasePublisher(upstream: p1.eraseToAnyPublisher())</pre><pre name="2e79" id="2e79" class="graf graf--pre graf-after--pre">let subscriber = StringSubscriber()<br>p2.subscribe(subscriber)</pre><p name="4479" id="4479" class="graf graf--p graf-after--pre">Output:<code class="markup--code markup--p-code"> Char: H e l l o W o r l d Subscriber completion finished</code></p><h3 name="601d" id="601d" class="graf graf--h3 graf-after--p">Operator</h3><p name="41c1" id="41c1" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Publisher</em> and <em class="markup--em markup--p-em">Subscriber</em> I understood fairly quickly, and I sorta kinda got the concept of a <em class="markup--em markup--p-em">Complex Publisher,</em> but I really struggled with <em class="markup--em markup--p-em">Operator</em>. You’ll read that an <em class="markup--em markup--p-em">Operator</em> is a function that can be a combined <em class="markup--em markup--p-em">Publisher-Subscriber</em>, but I struggled with how you could apply it as a function to another <em class="markup--em markup--p-em">Publisher</em>.</p><p name="d1b1" id="d1b1" class="graf graf--p graf-after--p">Finally, at some point looking at some one else&#39;s code, I <em class="markup--em markup--p-em">got</em> it: the function is just a mechanism to leverage an actual <em class="markup--em markup--p-em">Complex Publisher</em>. The function by definition is an extension to <em class="markup--em markup--p-em">Publisher</em>, and so can be applied to any <em class="markup--em markup--p-em">Publisher</em> (given <em class="markup--em markup--p-em">associated type</em> constraints).</p><p name="04fa" id="04fa" class="graf graf--p graf-after--p">So lets create an <em class="markup--em markup--p-em">Operator</em> for the <em class="markup--em markup--p-em">UpperCasePublisher</em> above:</p><pre name="b6f7" id="b6f7" class="graf graf--pre graf-after--p">extension Publisher where Output == [Character], Failure == Error {<br> func toUpper() -&gt; AnyPublisher&lt;Output, Failure&gt; {<br>  let p2 = UpperCasePublisher(upstream: self.eraseToAnyPublisher())<br>  return p2.eraseToAnyPublisher()<br> }<br>}</pre><p name="570e" id="570e" class="graf graf--p graf-after--pre">In use:</p><pre name="9144" id="9144" class="graf graf--pre graf-after--p">let p2 = StringPublisher(string: &quot;Hello World&quot;).toUpper()<br>let subscriber = StringSubscriber()<br>p2.subscribe(subscriber)</pre><p name="7bdf" id="7bdf" class="graf graf--p graf-after--pre">Or, using <em class="markup--em markup--p-em">sink</em>:</p><pre name="8d88" id="8d88" class="graf graf--pre graf-after--p">var count = 0<br>let _ = StringPublisher(string: &quot;Hello World&quot;)<br>.toUpper()<br>.sink(<br> receiveCompletion: { completion in<br>  switch completion {<br>  case .failure(let err):<br>   print(&quot;\nERROR: &quot;, err)<br>  case .finished:<br>   print(&quot;\nFINISHED&quot;)<br>  }<br> }) { (chars: [Character]) in<br>  chars.forEach({ print(count == 0 ? &quot;Char:&quot; : &quot; &quot;, $0, terminator: &quot;&quot;); count += 1 })<br> }</pre><p name="a734" id="a734" class="graf graf--p graf-after--pre">This outputs exactly the same text as the earlier tests</p><h3 name="02bf" id="02bf" class="graf graf--h3 graf-after--p">Back Pressure, Revisited</h3><p name="4784" id="4784" class="graf graf--p graf-after--h3">I’ve found three discussions of back pressure, and they all have slightly different takes on exactly how <em class="markup--em markup--p-em">Publishers</em> should treat the two types of <code class="markup--code markup--p-code">demand</code> (<code class="markup--code markup--p-code">receive</code> messages, and return <code class="markup--code markup--p-code">demand</code> from <code class="markup--code markup--p-code">request</code>). I don’t have any special insight into this other than my take on Apples scant documentation.</p><ul class="postList"><li name="8839" id="8839" class="graf graf--li graf-after--p"><a href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-3.html" data-href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-3.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Supply and Demand</a>, Matt Gallagher, from August 2019</li><li name="c160" id="c160" class="graf graf--li graf-after--li"><a href="https://heckj.github.io/swiftui-notes/" data-href="https://heckj.github.io/swiftui-notes/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Back pressure</a>, Joe Heck, March 2020</li><li name="c1f5" id="c1f5" class="graf graf--li graf-after--li"><a href="https://www.apeth.com/UnderstandingCombine/publishers/publisherscustom.html" data-href="https://www.apeth.com/UnderstandingCombine/publishers/publisherscustom.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Responding to Backpressure</a>, Matt Neuburg, March 2020</li><li name="3f58" id="3f58" class="graf graf--li graf-after--li"><a href="https://www.donnywals.com/understanding-combines-publishers-and-subscribers/" data-href="https://www.donnywals.com/understanding-combines-publishers-and-subscribers/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Understanding Combine’s publishers and subscribers</a>, Donny Wals</li></ul><p name="8a70" id="8a70" class="graf graf--p graf-after--li">Matt Gallagher says that <em class="markup--em markup--p-em">Publishers</em> should discard data if there is no current <code class="markup--code markup--p-code">demand</code>, something as a dev coming from the UNIX world could never accept (note my code provides an elastic buffer). That said, maintaining a buffer that interfaces an upstream <em class="markup--em markup--p-em">Publisher</em> with a downstream <em class="markup--em markup--p-em">Subscriber</em>, as many <em class="markup--em markup--p-em">Operators</em> do, raises a raft of issues on thread synchronization that I hope to explore in a future article.</p><h3 name="124e" id="124e" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="af07" id="af07" class="graf graf--p graf-after--h3">I love <em class="markup--em markup--p-em">Combine</em> and am continuing to learn more every day. I’m in the process of upgrading several of my open source projects that currently support <em class="markup--em markup--p-em">Steams</em> to offer <em class="markup--em markup--p-em">Combine</em> interfaces. The code I wrote for this article was a huge help to me personally to better understand <em class="markup--em markup--p-em">Combine</em>, in particular the <em class="markup--em markup--p-em">Complex Publisher</em> and <em class="markup--em markup--p-em">Operator</em> concepts. Again, a huge thanks to <a href="https://www.cocoawithlove.com/about/" data-href="https://www.cocoawithlove.com/about/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Matt Gallagher</a>!</p><p name="029b" id="029b" class="graf graf--p graf-after--p">Since I started writing this article, a slew of others have appeared that also cover writing custom <em class="markup--em markup--p-em">Combine</em> components with <em class="markup--em markup--p-em">back pressure</em>. I’ve added some links below if you want to delve further.</p><p name="0736" id="0736" class="graf graf--p graf-after--p">All the above code can be found in a <a href="https://github.com/dhoerl/MediumCombineExamples" data-href="https://github.com/dhoerl/MediumCombineExamples" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Github Playground</a>. And thanks so much for reading—hope you got something useful from it!</p><h3 name="4fc5" id="4fc5" class="graf graf--h3 graf-after--p">Coda</h3><p name="4025" id="4025" class="graf graf--p graf-after--h3">There are more articles on using Combine, and writing Combine components, than I could ever properly list (and the list gets longer every day!). That said, I’d like to highlight a select few, some previously referenced:</p><ol class="postList"><li name="d8c3" id="d8c3" class="graf graf--li graf-after--p"><a href="https://www.apeth.com/UnderstandingCombine/start.html" data-href="https://www.apeth.com/UnderstandingCombine/start.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Introducing Combine</a> by Matt Neuburg. Matt has written incredibly useful Apple documentation, going back to <em class="markup--em markup--li-em">AppleScript</em>, and more recently tomes covering each iOS release (just out: <a href="https://www.amazon.com/Programming-iOS-13-Controllers-Frameworks/dp/1492074616" data-href="https://www.amazon.com/Programming-iOS-13-Controllers-Frameworks/dp/1492074616" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Programming iOS 13: Dive Deep into Views, View Controllers, and Frameworks</a>. Discussions in these books have truly helped me understand difficult and complex topics and I just cannot recommend his writing enough!</li><li name="5f71" id="5f71" class="graf graf--li graf-after--li"><a href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-1.html" data-href="https://www.cocoawithlove.com/blog/twenty-two-short-tests-of-combine-part-1.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">22 short tests of Combine</a>, Matt Gallaher. To better understand <em class="markup--em markup--li-em">Combine</em>, Matt wrote a series of tests to explore the <em class="markup--em markup--li-em">Combine</em> innards. While these three articles are a slow read, they offer true insight into the <em class="markup--em markup--li-em">hows</em> and <em class="markup--em markup--li-em">whys</em> of <em class="markup--em markup--li-em">Combine</em>.</li><li name="28fe" id="28fe" class="graf graf--li graf-after--li graf--trailing"><a href="https://heckj.github.io/swiftui-notes/#aboutthisbook" data-href="https://heckj.github.io/swiftui-notes/#aboutthisbook" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Using Combine</a>, Joe Heck. Joe’s book was my first in-depth look at <em class="markup--em markup--li-em">Combine</em>, and while it’s more focused on usage, there are many insights on internals.</li></ol></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@dhoerl" class="p-author h-card">David Hoerl</a> on <a href="https://medium.com/p/c19188049533"><time class="dt-published" datetime="2020-03-31T20:04:59.305Z">March 31, 2020</time></a>.</p><p><a href="https://medium.com/@dhoerl/simple-combine-publisher-subscriber-and-operator-with-back-pressure-c19188049533" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 1, 2020.</p></footer></article></body></html>